package com.sabancihan.collectionservice.service;

import com.datastax.oss.driver.api.core.cql.BoundStatement;
import com.datastax.oss.driver.api.core.cql.PreparedStatement;
import com.sabancihan.collectionservice.dto.*;
import com.sabancihan.collectionservice.mapper.VulnerabilityMapper;
import com.sabancihan.collectionservice.model.Vulnerability;
import com.sabancihan.collectionservice.repository.VulnerabilityRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.stream.function.StreamBridge;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.data.cassandra.core.AsyncCassandraTemplate;
import org.springframework.data.cassandra.core.query.CassandraPageRequest;
import org.springframework.data.domain.Slice;
import org.springframework.data.domain.SliceImpl;
import org.springframework.http.MediaType;
import org.springframework.messaging.Message;
import org.springframework.messaging.support.MessageBuilder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.reactive.function.client.WebClient;

import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@RequiredArgsConstructor
@Service
@Transactional
@Configuration
@Slf4j

public class VulnerabilityService {

    private final VulnerabilityMapper vulnerabilityMapper;

    private final VulnerabilityRepository vulnerabilityRepository;

    private final AsyncCassandraTemplate cassandraTemplate;


    private final WebClient.Builder webClientBuilder;


    private final PreparedStatement preparedStatement;


    private final StreamBridge streamBridge;




    public List<VulnerabilityResponse> getVulnerabilityBySoftware(String vendor_name,String software_name) {
        log.info("Getting vulnerability by vendor_name {} and software_name {}", vendor_name, software_name);
        return vulnerabilityMapper.vulnerabilitiesToVulnerabilityResponses(vulnerabilityRepository.findByVendorNameAndSoftwareName(vendor_name,software_name));


    }

    public Slice<VulnerabilityResponse> getAllVulnerabilities(Integer page, Integer size) {

        log.info("Getting all vulnerabilities with page {} and size {}", page, size);

        Slice<Vulnerability> vulnerabilities = vulnerabilityRepository.findAll(CassandraPageRequest.of(page, size));

        List<VulnerabilityResponse>  vulnerabilityResponses = vulnerabilityMapper.vulnerabilitiesToVulnerabilityResponses(vulnerabilities.getContent());

        return new SliceImpl<>(vulnerabilityResponses,vulnerabilities.getPageable(), vulnerabilities.hasNext());
    }


    private  List<SoftwareVulnerabilityDTO> optimizedVulnSearch(BoundStatement bind) throws ExecutionException, InterruptedException {


        return cassandraTemplate.select(bind, SoftwareVulnerabilityDTO.class).get();

    }



    public CompletableFuture<DetectionVulnerabiltiyDTO>  getAsyncVulnerabilities(ManagementVulnerabilityDTO managementVulnerabilityDTO) {
        return CompletableFuture.supplyAsync(() -> {

            try {

                String softwareName = managementVulnerabilityDTO.getSoftwareName();
                String vendorName = managementVulnerabilityDTO.getVendorName();
                BoundStatement statement = preparedStatement.bind(vendorName, softwareName);
                List<SoftwareVulnerabilityDTO> softwareVulnerabilityDTOS = optimizedVulnSearch(statement);

                return DetectionVulnerabiltiyDTO.builder()
                        .softwareName(softwareName)
                        .vendorName(vendorName)
                        .usedVersion(managementVulnerabilityDTO.getVersion())
                        .affected_versions(softwareVulnerabilityDTOS)
                        .build();

            } catch (Exception e) {
                log.error("Error while getting vulnerabilities for management update {}", e.getMessage());
                return null;
            }

        });
    }






    @Bean
    public Consumer<Message<ManagementUpdateDTO>> managementUpdateEventSupplier() {
        return message -> {
            ManagementUpdateDTO managementUpdateDTO = message.getPayload();
            log.info("Received management update {}", managementUpdateDTO);
            handleUpdate(managementUpdateDTO);
        };

    }

    public void handleUpdate(ManagementUpdateDTO managementUpdateDTO) {
        var vulnerabilitiesManagement =  managementUpdateDTO.getVulnerabilities();



        //todo efficiency could be improved by grouping by vendor_name and software_name



        CompletableFuture<DetectionVulnerabiltiyDTO>[] detectionVulns = vulnerabilitiesManagement.stream().map(this::getAsyncVulnerabilities).toArray(CompletableFuture[]::new);
        CompletableFuture.allOf(detectionVulns).thenApply(v -> {
            List<DetectionVulnerabiltiyDTO> detectionVulnerabiltiyDTOS = Stream.of(detectionVulns).map(CompletableFuture::join).toList();

            if (detectionVulnerabiltiyDTOS.isEmpty()) {
                log.info("No vulnerabilities found for management update {}", managementUpdateDTO);
                return null;
            }

            log.info("Sending detection vulnerabilities {}", detectionVulnerabiltiyDTOS);

            return  streamBridge.send("detectionEventSupplier-out-0", MessageBuilder.withPayload(
                            DetectionRequestDTO.builder()
                                    .email(managementUpdateDTO.getEmail())
                                    .ipAddress(managementUpdateDTO.getIpAddress())
                                    .vulnerabilities(detectionVulnerabiltiyDTOS)
                                    .build()

                    )
                    .build());

        });

    };


    public void handleInitUpdates() {

        List<ManagementUpdateDTO> managementUpdateDTOs = webClientBuilder.build()
                .get()
                .uri("http://management-service/api/management/softwareVersioned/grouped")
                .retrieve()
                .bodyToMono(new ParameterizedTypeReference<List<ManagementUpdateDTO>>() {
                })
                .block();

        if (managementUpdateDTOs == null) {
            log.info("No management updates found");
            return;
        }


        managementUpdateDTOs.forEach(this::handleUpdate);

    }
}
