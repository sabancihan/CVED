package com.sabancihan.collectionservice.service;

import com.datastax.oss.driver.api.core.CqlSession;
import com.datastax.oss.driver.api.core.cql.BoundStatement;
import com.datastax.oss.driver.api.core.cql.PreparedStatement;
import com.sabancihan.collectionservice.collector.VulnMapping;
import com.sabancihan.collectionservice.dto.*;
import com.sabancihan.collectionservice.mapper.VulnerabilityMapper;
import com.sabancihan.collectionservice.model.Vulnerability;
import com.sabancihan.collectionservice.repository.VulnerabilityRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.stream.function.StreamBridge;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.cassandra.core.AsyncCassandraTemplate;
import org.springframework.data.cassandra.core.query.CassandraPageRequest;
import org.springframework.data.domain.Slice;
import org.springframework.data.domain.SliceImpl;
import org.springframework.messaging.Message;
import org.springframework.messaging.support.MessageBuilder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.function.Consumer;

@RequiredArgsConstructor
@Service
@Transactional
@Configuration
@Slf4j

public class VulnerabilityService {

    private final VulnerabilityMapper vulnerabilityMapper;

    private final VulnerabilityRepository vulnerabilityRepository;

    private final AsyncCassandraTemplate cassandraTemplate;



    private final CqlSession session;


    private final StreamBridge streamBridge;


    public List<VulnerabilityResponse> getVulnerabilityBySoftware(String vendor_name,String software_name) {
        log.info("Getting vulnerability by vendor_name {} and software_name {}", vendor_name, software_name);
        return vulnerabilityMapper.vulnerabilitiesToVulnerabilityResponses(vulnerabilityRepository.findByVendorNameAndSoftwareName(vendor_name,software_name));


    }

    public Slice<VulnerabilityResponse> getAllVulnerabilities(Integer page, Integer size) {

        log.info("Getting all vulnerabilities with page {} and size {}", page, size);

        Slice<Vulnerability> vulnerabilities = vulnerabilityRepository.findAll(CassandraPageRequest.of(page, size));

        List<VulnerabilityResponse>  vulnerabilityResponses = vulnerabilityMapper.vulnerabilitiesToVulnerabilityResponses(vulnerabilities.getContent());

        return new SliceImpl<>(vulnerabilityResponses,vulnerabilities.getPageable(), vulnerabilities.hasNext());
    }


    private  List<SoftwareVulnerabilityDTO> optimizedVulnSearch(BoundStatement bind) throws ExecutionException, InterruptedException {
        return cassandraTemplate.select(bind, SoftwareVulnerabilityDTO.class).get();

    }




    @Bean
    public Consumer<Message<ManagementUpdateDTO>> managementUpdateEventSupplier() {
        return message -> {
            ManagementUpdateDTO managementUpdateDTO = message.getPayload();
            log.info("Received management update {}", managementUpdateDTO);

            var vulnerabilitiesManagement =  managementUpdateDTO.getVulnerabilities();


            final String selectStatement = "SELECT id,affected_versions FROM vulnerability WHERE vendor_name = ? AND software_name = ?";
            final PreparedStatement preparedStatement =  session.prepare(selectStatement);






            //todo efficiency could be improved by grouping by vendor_name and software_name

            List<DetectionVulnerabiltiyDTO> detectionVulnerabiltiyDTOS =  vulnerabilitiesManagement.stream().map(vulnerabilityManagement -> {

                        try {

                            String softwareName = vulnerabilityManagement.getSoftwareName();
                            String vendorName = vulnerabilityManagement.getVendorName();
                            BoundStatement statement = preparedStatement.bind(vendorName, softwareName);
                            List<SoftwareVulnerabilityDTO> softwareVulnerabilityDTOS = optimizedVulnSearch(statement);

                            return DetectionVulnerabiltiyDTO.builder()
                                    .softwareName(softwareName)
                                    .vendorName(vendorName)
                                    .usedVersion(vulnerabilityManagement.getVersion())
                                    .affectedVersions(softwareVulnerabilityDTOS)
                                    .build();

                        } catch (Exception e) {
                            log.error("Error while getting vulnerabilities for management update {}", e.getMessage());
                            return null;
                        }
                    }


            ).toList();


            streamBridge.send("detectionEventSupplier-out-0", MessageBuilder.withPayload(
                    DetectionRequestDTO.builder()
                            .email(managementUpdateDTO.getEmail())
                            .ipAddress(managementUpdateDTO.getIpAddress())
                            .vulnerabilities(detectionVulnerabiltiyDTOS)
                            .build()

                    )
                    .build());

        };
    }
}
